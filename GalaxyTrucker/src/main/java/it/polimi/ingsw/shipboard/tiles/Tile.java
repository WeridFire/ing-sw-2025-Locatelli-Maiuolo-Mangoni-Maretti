package src.main.java.it.polimi.ingsw.shipboard.tiles;

import src.main.java.it.polimi.ingsw.enums.*;
import src.main.java.it.polimi.ingsw.shipboard.tiles.content.TileContent;
import src.main.java.it.polimi.ingsw.shipboard.tiles.exceptions.IncoherentBatteryUsageException;
import src.main.java.it.polimi.ingsw.shipboard.tiles.side.TileSide;

import java.io.Serializable;

/**
 * Represents a tile in the game, which consists of four sides and a main content.
 * <p>
 * Each tile has a side facing East, North, West, and South, which determines its connectivity
 * with adjacent tiles and implements specific effects that are intrinsically directed (e.g. cannons).
 * The tile also has a specific content, which is not affected by tile's rotation.
 * </p>
 *
 * @see TileSide
 * @see TileContent
 */
public class Tile extends TileSkeleton<TileSide, TileContent> implements Serializable {

    /**
     * Constructs a new tile with four specified sides and a content.
     * <p>
     * The order of the sides follows the East, North, West, and South convention.
     * The content does not change when the tile is rotated.
     * </p>
     *
     * @param eastSide  The tile's East side.
     * @param northSide The tile's North side.
     * @param westSide  The tile's West side.
     * @param southSide The tile's South side.
     * @param content   The content of the tile.
     */
    public Tile(TileSide eastSide, TileSide northSide, TileSide westSide, TileSide southSide, TileContent content) {
        super(Direction.sortedArray(eastSide, northSide, westSide, southSide).toArray(new TileSide[0]), content);
    }

    /**
     * Retrieves the content of this tile.
     *
     * @return The {@link TileContent} associated with this tile.
     */
    public TileContent getContent() {
        return content;
    }

    /**
     * Retrieves the tile side corresponding to the given direction.
     *
     * @param direction The direction for which to retrieve the tile side.
     * @return The {@link TileSide} in the specified direction.
     */
    public TileSide getSide(Direction direction) {
        return sides[direction.getValue()];
    }

    /**
     * Calculates the total power generated by this tile for a given power type,
     * considering whether battery usage is enabled.
     * <p>
     * If an exception related to battery usage occurs, that side's power is ignored.
     * </p>
     *
     * @param powerType The type of power to calculate.
     * @param batteryUsage {@code true} if battery power is used, {@code false} otherwise.
     * @return The total power generated by this tile for the specified power type.
     */
    private float calculatePower(PowerType powerType, boolean batteryUsage) {
        float power = 0;
        for (TileSide side : sides) {
            try {
                power += side.calculatePower(powerType, batteryUsage);
            } catch (IncoherentBatteryUsageException _) {
                // Ignore power from this side in case of an exception.
            }
        }
        return power;
    }

    /**
     * Calculates the amount of power generated by this tile without battery usage.
     *
     * @param powerType The type of power to calculate.
     * @return The amount of power generated without battery usage.
     */
    public float calculateFreePower(PowerType powerType) {
        return calculatePower(powerType, false);
    }

    /**
     * Calculates the amount of power generated by this tile with battery usage enabled.
     *
     * @param powerType The type of power to calculate.
     * @return The amount of power generated when using battery power.
     */
    public float calculateBatteryPower(PowerType powerType) {
        return calculatePower(powerType, true);
    }

    /**
     * Checks the connection status between this tile and a neighboring tile.
     * <p>
     * The connection status is determined by comparing the side of this tile
     * facing the given direction with the corresponding side of the neighboring tile.
     * </p>
     *
     * @param neighbor The adjacent tile to check the connection with.
     * @param selfDirection The direction in which this tile is facing the neighbor.
     * @return The {@link TilesConnectionStatus} indicating the validity of the connection.
     */
    public TilesConnectionStatus checkNeighborConnection(Tile neighbor, Direction selfDirection) {
        return TileSide.calculateConnectionStatus(
                getSide(selfDirection),
                neighbor.getSide(selfDirection.getRotated(Rotation.OPPOSITE))
        );
    }

    /**
     * Determines whether the current orientation of the tile is valid.
     * <p>
     * A tile's orientation is considered valid if all its sides have a valid orientation.
     * </p>
     *
     * @return {@code true} if all tile sides have a valid orientation, {@code false} otherwise.
     */
    public boolean isValidRotation() {
        for (TileSide side : sides) {
            if (!side.isOrientationValid()) {
                return false;
            }
        }
        return true;
    }
}

